#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <stack>

using namespace std;

/*
rgb 거리 2

집이 N개 있따.
1번집부터 N번집이 순서대로 있다.

rgb거리1과 다르점
1번집은 2번과 N번 집의 색과 같지 않아야함.
N번집은 n-1,1번집과 색이 같지 않아야함.
i는 i-1,i+1과 색이 같지 않아야함
->원형이라고 보면됨. 마지막과 시작이 서로 이웃하는.


*/

int dp[1001][3];
int a[1001][3];

/*
0=R 1=G 2=B
dp[i][j] = i번째 집을 j로 칠했을때, i번째 집까지 페인트 칠 하는데
드는 비용의 최솟값.
*/
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n;
	cin >> n;

	for (int i = 1; i <= n; i++) {
		cin >> a[i][0] >> a[i][1] >> a[i][2];
	}
	//1~N번까지 집에 대해 r g b 로 칠하는 값 입력 받음.
	//dp[1][0] = a[1][0]; dp[1][1] = a[1][1]; dp[1][2] = a[1][2];
	//첫번째 집에 대한 페인트 값은 그냥 그대로 넣음.

	/*
	직선으로 문제를 풀고 원형으로 바꾸면 되는데,
	원형으로 바꾸는 방법은
	처음과 마지막에 대한 예외처리를 해줘야한다.

	->직선으로 문제를 풀고
	처음이나 마지막을 고정시키고 문제를 나눠서 푼다.
	->1번집을 R G B로 고정하고 풀어서 dp를 총 3번 진행해야함.
	*/

	int ans = 1000 * 1000 + 1;
	for (int k = 0; k < 3; k++) {
		for (int j = 0; j < 3; j++) {
			if (j == k) {
				dp[1][j] = a[1][k];
				//첫번째 집의 색깔을 k for문을 돌면서 0 1 2 로 돌면서 고정시킴.
			}
			else dp[1][j] = 1000 * 1000 + 1;//아닌경우 경계값을 넣음.
		}
		//dp for문을 3번 돌린다. 그리고 첫번째 반복문에서 j와 k가 같은경우
		//1번째 집의 색깔을 고정시킨다. 그 방법은 j가 k와 같은 경우 그 집만 rgb의 제대로 된 값을
		//넣어주고, 나머지 경우엔 최대값을 넣어서 j인 경우만 dp가 진행되게끔.
		//j가 0이면 첫번째 집은 빨간색 고정. j가 1이면 초록색 2면 파란색 고정.
		for (int i = 2; i <= n; i++) {
			dp[i][0] = min(dp[i - 1][1], dp[i - 1][2]) + a[i][0];
			dp[i][1] = min(dp[i - 1][0], dp[i - 1][2]) + a[i][1];
			dp[i][2] = min(dp[i - 1][0], dp[i - 1][1]) + a[i][2];
		}

		//이 for문에서는 j가 k와 같은 경우(마지막 집이 첫번째 집과 색깔이 같은경우)
		//넘어가고, j!=k인 경우에만 정답을 따진다. j는 k와 같지 않은 경우 모두 따지니까
		//결과적으로 ans엔 dp[n][0][1][2]중 첫번째 집과 색깔이 겹치지 않는 최소값이 담긴다.
		//가장 큰 for문을 k로 달아놓고, k와 첫번째 집 색깔을 통일 시켜놨으니까
		//이 for문에서 j가 k와 같다는건, 첫번째 집과 N번째 집 색깔이 같다는거니까 통과시킴.
		for (int j = 0; j < 3; j++) {
			if (j == k) continue;//첫번째 집과 같다면 통과
			ans = min(ans, dp[n][j]);//아니면 최소값 따지기.
		}
	}
	cout << ans << endl;
}
