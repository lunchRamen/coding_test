#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <iostream>
#include <string>
#include <string.h>

using namespace std;


/*
DP
정수  X로 할수 있는 연산의 경우
1.X가 3으로 나누어 떨어지는 경우 3으로 나눈다.z
2.X가 2로 나누어 떨어지는 경우 2로 나눈다.
3.1,2 둘다 아니면 X에서 1을 뺀다.

1,2,3 연산을 이용해서 입력받은 정수 X를 1로 만들 예정. 연산을 사용하는 최소의 경우 출력.

DP-> 모든 경우를 비교해서 최단경로를 찾는 문제.
내가 방금 짠 코드 같은 경우, if조건문으로 순서대로 통과해서 10->5->4->2->1 이런 순서로
진행돼서 4번이 되는데,
정답코드의 경우 10->9->3->1 이렇게 3번으로 끝날 수 있다. 그렇다면 코드를 어떻게 짜야할까?

일단, 모든 DP문제는 Top down 형태가 아닌 Bottom up 형태로 풀어야 한다.
대표적인 DP문제인 Fibonacci 문제에서  n=10일 경우를 구해보면 중복 계산 되는 경우가 많지만
n=2~10까지 구하고 n=x인 경우에 대해서는 그 경우의 수를 저장해 두면 중복계산이 되지 않기
때문에 계산 횟수를 줄여줄 수 있음.


*/
//int main(void) {
//	int x;
//	scanf("%d", &x);
//	int count = 0;
//
//	while (x != 1) {
//		if ((x % 3) == 0) {
//			x = x / 3;
//			count++;
//			printf("%d", x);
//			continue;
//		}
//		else if ((x % 2) == 0) {
//			x = x / 2;
//			count++;
//			printf("%d", x);
//			continue;
//		}
//		else {
//			x = x - 1;
//			count++;
//			printf("%d", x);
//			continue;
//		}
//	}
//	printf("%d",count);	 
//	return 0;
//} 이렇게 푸는 방식은 단지 if조건문 순서대로 문제를 풀고 해당 조건문이 실행되면 다시
//반복문을 도는 구조라서 3개의 반복문중에서 뭐가 가장 효율적인지를 판별 할 수 가 없다.


int n[1000001] = { 0 };

int min(int x,int y) {
	if ((x < y) && (x != 0) && (y != 0)) return x;
	else return y;
	//min 함수는 더 작고 두 수가 0이 아닌경우에 더 작은 값을 return 해주도록 설정.
}
int main(void) {
	int x;
	scanf("%d", &x);

	//1. x%3==0 2.x%2==0 3.x-1 if x==1 break;
	//1이나 2가 된다면 이걸 먼저 한다.
	//1이나 2가 안된다면 3을 실행한다.
	//이건 X를 입력받아서 1이 될때까지 실행하는 경우(top down)이고
	//우리는 1부터 시작해서 X까지 bottom up으로 올라간다.
	//그렇다면, x/3은 x*3으로 x/2는 x*2로 x-1은 x+1로 거꾸로 생각해야 함.
	//그렇다면 연산 횟수를 count하는 n배열의 index가 1씩 커지는 경우 *2씩 커지는 경우
	//*3씩 커지는 경우 3가지 나눠서 반복문을 돌리고
	//+1씩 되는 경우는 모든 경우 다 돌기 때문에, 먼저 연산된 *2와 *3과 비교해서
	//더 작은 숫자를 넣어줘야 최소 연산의 조건을 충족 시키기 때문에 두개의 값을
	//비교해주는 min 함수를 만든다.

	for (int i = 1; i <= x; i++)
	{	
		n[i + 1] = min(n[i+1],n[i]+1);
		n[i * 2] = min(n[i*2],n[i]+1);
		n[i * 3] = min(n[i*3],n[i]+1);
		//0부터 시작하고
		//+1 *2 *3 모든 경우에 있어서 다음 숫자를 탐색할때 그 전 숫자의 연산 횟수+1
		//보다 작은 경우에만 갱신되게끔 해줌.
		//ex) n[2]=min(n[2],n[1]+1)=min(0,1)인데 둘다 0이 아닌 경우에만 대소 비교를
		//하기때문에,1이 들어간다.
		//	  n[2]=min(n[2],n[1]+1)=min(0,1)
		//	  n[3]=min(n[3],n[i]+1)=min(0,1)
		//->n[2],n[3]에 3 들어감.
		//n[3]=min(n[3],n[2]+1)=min(1,2) -> 1
		//n[4]=min(n[4],n[2]+1)=min(0,2) -> 4에는 2가 들어간다.
		//n[6]=min(n[6],n[2]+1)=min(0,2) -> 6에는 2가 들어간다.

		//이렇게 min의 조건문에서 비교할 두개의 수 다 0이 아니여야 대소비교를 하고
		//아니면 0이 아닌 값을 넣기때문에 DP가 진행된다.
		//->0일때, 
	}
	printf("%d", n[x]);
	return 0;
}
