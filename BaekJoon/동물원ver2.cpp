#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <stack>

using namespace std;
/*
동물원
가로로 2칸 세로로 N칸인 우리가 있다.
이 우리엔 사자들이 살고 있는데, 사자들을 우리에 가둘 때
가로로도 세로로도 붙어있게 배치 X
->대각선으로만 배치 가능.

사자를 0마리부터 배치를 하는데
조건에 맞게끔 최대한 꽉 찰 때까지

하나의 가로에 대해서
안놓는거 왼쪽 오른쪽 3가지 경우 가능.
dp[n][0]=배치 x
dp[n][1]=왼쪽
dp[n][2]=오른쪽

앞에 놓인 경우 생각
dp[n][0]경우 ->dp[n-1][0],[1],[2] 다 가능
dp[n][1]경우 ->dp[n-1][0],[2] 가능
dp[n][2]경우 ->dp[n-1][0],[1] 가능

->dp를 2차원 배열로 설정할때는
뒷배열엔 방향,색깔등등 표시를 해줘야 할때 쓴다.
---쉬운버전
*/

/*
어려운버전
1차원 배열로. 사자를 우리에 안넣는 경우를 제외하고 코드를 작성.
dp[i]=세로크기가 i인 우리에 동물을 채우는 방법의 수. i번째엔 동물이 있어야함.
->i번째 우리 이전에 동물이 있는줄은 몇번째 줄일까?
알수없다. ->변수 사용
i-k번째라고 둔다.

동물을 추가할 수 없는 조건을 추가해준다.
만약 i번째의 왼쪽에 놨다면
i-1번째는 오른쪽에만
i-2~1번째 까지는 양쪽 다 놓을수 있다.

dp[i]=dp[i-1](한가지 방법만 되니까)
dp[i]=dp[i-2]x2 ->1이 될때까지.

이건 i개의 문제를 n번 검사해서 하니까 시간복잡도가 n^2
근데 입력이 10만개라 이러면 시간초과가 나옴.
->시간 복잡도를 낮출 방법이 필요.

dp의 합을 저장하는 s[i]를 만들어 해결 가능.
s[i]=dp[1]+...+dp[i]
-> dp[i]=dp[i-1]+s[i-2]x2로 나타낼수 있다.

이러면, 합을 table에 저장해놓는거니까 n번의 검사 필요 x
->시간복잡도를 n으로 낮출수 있음

그리고 답은 dp[i]가 아니라 s[i]가 정답.
왜냐하면 dp[i]를 세울때 조건이 i번째에 동물을 넣는다는건데,
원래 동물원 문제에선 안넣는 경우도 존재하기때문에.
*/

int dp[100001];
int s[100001];

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	
	int n;
	cin >> n;
	
	dp[0] = 1;//안놓는 경우
	s[0] = 1;

	dp[1] = 2;//1번째 줄에 사자를 놓는경우
			  //왼쪽에 놓음 오른쪽에 놓음 2가지 경우 가능.
	s[1] = dp[0] + dp[1];//고로 합은 해당 줄까지 사자를 놓는 모든 경우의 합.
	

	for (int i = 2; i <= n; i++) {
		dp[i] = dp[i - 1] + 2 * s[i - 2];
		//i번째 줄에 사자를 놓는 경우는 i-1번째의 반대 경우 1가지+ i-2번째부턴
		//왼쪽 오른쪽 다 가능하고,dp의 정의 자체를 i번째에 사자를 놓는 경우의 수로 했으니까
		//i-2~1번째까지 왼쪽 오른쪽 둘다 가능이라 s[i-2]*2.
		s[i] = s[i - 1] + dp[i];
		//s[i]는 s[i-1]+dp[i]로 갱신.
		dp[i] %= 9901;
		s[i] %= 9901;
	}

	cout << s[n] << endl;

}
