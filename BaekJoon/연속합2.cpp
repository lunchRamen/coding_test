	#include <iostream>
	#include <vector>
	#include <algorithm>
	#include <string>
	#include <stack>

	using namespace std;

	/*
	연속합 2

	n개의 정수로 이루어진 임의의 수열.

	"연속된"몇개의 수를 선택해서 최대합 구하기.

	특별한 조건
	->수열에서 수를 하나 제거 할 수 있다.

	이전 연속합의 경우
	10 -4 3 1 5 6 -35 12 21 -1이여서
	최대값이 33인데

	이번문제의 경우 하나 제거 가능해서
	10 -4 3 1 5 6 12 21 -1로 보고

	10+-4+3+1+5+6+12+21로 최대값이 54가 나옴.

	dp[n]=1~n번째까지의 부분수열의 연속합이 최대가 되게끔 하는 값.

	dp[n]=max(dp[n-1])+a[n].

	여기서 수를 하나 제거할 수 있다는
	조건을 추가하는 방법.

	a[i]>dp[i-1]+a[i]?

	연속합: n의 시간복잡도.
	(단순히 두개의 수 비교를 n번 반복)

	2가지로 풀 수 있음
	1~n에 대해서
	1번째 수 제거하고 연속합 구하고
	...n번째 수 제거하고 연속합 구해서
	최대값 뽑기.
	-> n^2의 시간복잡도.

	2번째.
	어떤 수를 제거했을때
	연속합 값은 그 수를 포함한 값만
	변경이 된다
	-> 매번 전체를 구하는건 의미X
	dp[i]=i번째에서 끝나는 연속합.
	dp2[i]=i번째에서 시작하는 연속합.

	k번째 원소를 제거했을때
	k의 주변 원소의 연속합이 영향을 받는다.

	d[k-1]+d[k+1] -> k를 제거한 연속합의 최대값.

	*/

	int a[100001];

	int dp[100001];
	int dp2[100001];

	int main() {
		ios::sync_with_stdio(false);
		cin.tie(0);

		int n;
		cin >> n;

		for (int i = 1; i <= n; i++) {
			cin >> a[i];
		}

		dp[1] = a[1];
	
		//제거하지 않고 연속합.
		for (int i = 2; i <= n; i++) {
			dp[i] = a[i];
			if (dp[i] < dp[i - 1] + a[i]) {
				dp[i] = dp[i - 1] + a[i];
			}
			//a[i]가 dp[i-1]+a[i]보다 크다면
			//-> dp[i-1]의 값이 0보다 크다면
			//->dp[i-1]의 값이 a[i]의 값을 작게 만들지 않는다면
		}

		//제거하고 연속합.

		for (int i = n; i >= 1; i--) {
			dp2[i] = a[i];
			if (i == n) continue;
			if (dp2[i] < dp2[i + 1] + a[i]) {
				dp2[i] = dp2[i + 1] + a[i];
			}
		}

		//dp=i번째에서 끝나는거
		//dp2=i번째에서 시작하는거
		//->dp2는 n에서 시작해서 0까지 거꾸로 돌리는중
		//설명에서는 k를 기준으로 잡았을때
		//dp[k-1] dp2[k+1]이라고 했는데

		int ans = dp[1];
		for (int i = 2; i <= n; i++) {
			if (ans < dp[i]) ans = dp[i];
		}
		//일단 그냥 연속합을 ans에 집어넣고
		for (int i = 2; i <= n - 1; i++) {
			if (ans < dp[i - 1] + dp2[i + 1]) {
				ans = dp[i - 1] + dp2[i + 1];
			}
		}
		//i=1~n-1까지 i번째가 빠진 경우(하나 뺀 경우) 가 더 크다면
		//ans를 해당 값으로 새로 채워넣는다.
		cout << ans << endl;
	}
