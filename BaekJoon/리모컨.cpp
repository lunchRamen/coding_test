#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <stack>

using namespace std;

/*
리모컨
버튼: 0~9 + -
+ -> 채널+1
- -> 채널-1

채널 0번에서 -를 누른경우엔
채널이 변하지 않음(=음수채널없음)
채널은 무한대.

현재 100번 채널에서
입력받은 N번 채널로 갈때
고장난 버튼이 주어지면
몇번 버튼을 눌러야 가는지 출력.


100~N번까지
for문 돌려서
해당 버튼이 M배열에 있으면
제외하고 아니면 넣고
그래서 최대치까지 만들고
N될때까지 ++하는거
아님 --를 하던가.


ex)
5457 4번 눌러서 갈수 있음

7고장 나면

5456+ or 5458-해서 5번에 가능.

678 고장나면

5455++ or 5459-- 6번 가능.

최솟값->앞에 의미없는 입력은 필요없다.

1.숫자버튼으로 N의 최대한 근접하게 만들어놓고
2.++ or --로 N으로 간다.

이걸 코드로 바꾸려면

1.이동할 채널 c를 결정.
2.c에 포함되어있는 숫자중에 고장난 버튼이 있는지 확인
(수를 문자열로 바꿔서 한글자씩 검사하거나 수를 10으로 나눠서 나머지를 검사하거나)
3.이동횟수 출력

여기서는 int형으로 M을 안만들고
bool형으로 만들어서
고장났으면 true 아니면 false로 만듬.


brute force에서 어려운 문제
-> 전수검사할때 예외처리를 해줘야하는 경우가 많은 문제.

꼭 기억해야하는 점
"최소값" "최대값" "최단길이" "최소비용" 등등 최소 최대를 구할때
의미없는,중복되는 걸 추가하면 안된다.
*/


bool M[10];

int possible(int c) {
	if (c == 0) {
		//입력받은 숫자가 0이면
		if (M[0]) {//0번 버튼을 누를수 없는가?
			return 0;//0 return(이동불가)
		}
		else return 1;//누를수있으면 1번이면 갈수 있다.
	}
	int len = 0;
	while (c > 0) {//입력받은 채널이 0이상일때까지
		if (M[c % 10]) {//c를 10으로 나눈 나머지(일,십,백,천..의자리)가 버튼으로 못쓴다?
			return 0;//0 return
		}
		len += 1;//len 1더하고(버튼 누름)
		c = c / 10;//c를 10으로 나누고 다시 돌림
	}
	return len;
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int b = 100;
	int cnt = 0;

	int n;
	cin >> n;

	int m;
	cin >> m;
	
	for (int i = 0; i < m; i++) {
		int x;
		cin >> x;
		M[x] = true;
		//입력받은 버튼들은 못쓰는거니까 true로 바꿔줌.
	}

	int ans = n - 100;
	if (ans < 0) {
		ans = -ans;
	}
	//n-100-> +만 눌러서 n으로 가는경우
	//이걸로 초기값 설정.

	for (int i = 0; i <= 1000000; i++) {//입력이 50만인데 100만까지 돌리는이유 ->최악의 상황.
		int c = i;
		//이동하려고하는 채널 c결정.
		//채널이 N에서 작은수에서 ++하는게 최소일수도 큰수에서 --하는게 최소일수도 있으니까
		//100만까지 전수조사를 한다.
		int len = possible(c);
		//숫자버튼 몇번 눌러야하는지를 len에 넣고
		if (len > 0) {
			//불가능하면 0 return이니까
			//숫자버튼으로 이동 가능하면
			int press = c - n;
			//+나 - 버튼을 눌러야하는 횟수는 c-n.
			if (press < 0) press = -press;
			//횟수가 음수가 나왔으면 양수로 바꿔줌.
			if (ans > len + press) ans = len + press;
			//len=숫자버튼 누르는 횟수(애초에) press: +나 - 누르는 횟수.
		}	//숫자버튼+ (+-)버튼 누른 횟수가 ans보다 작으면
			//정답 갱신.
	}
	cout << ans << endl;

}
