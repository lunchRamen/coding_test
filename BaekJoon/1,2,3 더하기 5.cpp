#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <stack>

using namespace std;
/*
1,2,3 더하기 5 (15990)

1,2,3 더하기와 다른 조건
1.합을 나타낼때는 수를 1개이상.
2.같은수를 연속으로 2번 사용하면 안됨.
*/

long long dp[100001][4];
const long long mod = 1000000009LL;
//나눠줄 변수
const int limit = 100000;
//n이 100000보다 작거나 같은 조건용 변수

//일단 mod로 나눠줄 수가 엄청 크다보니까 다 long long으로 지정해준다.


int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);

	//보통 우리는 점화식에 필요한 기본 값들 몇개를 직접 지정해주고 그 다음 수부터 n까지
	//for문을 돌리면서 dp배열을 채웠었는데, 이번 경우는 dp[x][1].[2],[3]으로 마지막수를 따져줘야해서
	//그냥 dp를 모두 채워넣고, 그다음 n을 입력받으면 그에 맞는 dp[n][1]+dp[n][2]+dp[n][3]%mod를
	//출력해주면 됨
	
	//dp를 채우는 for문의 경우 n이 10만까지 입력 받을수 있기때문에 1~100000까지 돌리고
	//dp[i][j]가 중복될수 있는 경우는 i가 3까지인 경우니까 거기에 대한 예외처리를 해줘야함.
	//중복이 왜 일어나냐?
	//dp[1][1]의 경우 1이 마지막인 1이 되는 경우는 1가지인데
	//우리가 돌릴 dp[i][1]=dp[i-1][2]+dp[i-1][3]의 경우 따로 dp[0][2]와 dp[0][3]을 지정 안해줬다면
	//0이 나오고, 1로 지정해줬다면 2가 나온다. -> 우리가 원하는 답이 아님.
	//그래서 해당경우를 예외처리 해줘야함.
	//이런경우는 길이 기본단위인 1,2,3을 나눠줄때 해당됨.
	//셋 다 dp[1][1] dp[2][2] dp[3][3]의 경우는 1이 들어가야 하는데
	//dp[i][1] dp[i][2] dp[i][3]의 케이스로 생각하면 중복이 일어남.
	//또 그렇다고 dp[2][1]과 dp[3][1].dp[3][2]의 케이스가 중복이 일어나는 것은 아니기때문에
	//dp[1][1]~dp[3][3]을 모두 예외 처리해주거나 --1
	//i가 1,2,3인 경우에 대해서 1이면 dp[1][1] 2면 dp[2][2] 3이면 dp[3][3]에 대한 1을 할당해줌.


	for (int i = 1; i <= limit; i++) {
		if (i > 1) {
			dp[i][1] = dp[i - 1][2] + dp[i - 1][3];
		}
		if (i == 1) dp[i][1] = 1;

		if (i > 2) {
			dp[i][2] = dp[i - 2][1] + dp[i - 2][3];
		}
		if (i == 2) dp[i][2] = 1;
		
		if (i > 3) {
			dp[i][3] = dp[i - 3][1] + dp[i - 3][2];
		}
		if (i == 3) dp[i][3] = 1;

		dp[i][1] %= mod;
		dp[i][2] %= mod;
		dp[i][3] %= mod;
	}
	int t;
	cin >> t;

	while (t--) {
		int n;
		cin >> n;
		cout << (dp[n][1] + dp[n][2] + dp[n][3]) % mod << endl;
	}
}

